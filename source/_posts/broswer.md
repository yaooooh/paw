---
title: 浏览器渲染原理
date: 2025-04-04 16:31:42
tags: [浏览器, 渲染原理]
categories: [浏览器]
---

## 浏览器进程模型

最主要的进程包括：

1. 浏览器进程：主要负责界面展示、用户交互、子进程管理。浏览器进程内部会启动多个线程处理不同的任务
2. 网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务
3. 渲染进程：渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间互不影响

### 渲染进程

1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完之后进入下一个循环，如果没有，则进入休眠状态
3. 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加入到消息队列的末尾，在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务

### 异步

- 单线程是异步产生的原因
- 事件循环是异步实现的方式

JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面，执行 JS 都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程拜拜的消耗事件，另一方面导致页面无法及时更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听、主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他任务完成时，将实现传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

### 任务队列

**任务没有优先级，在消息队列中先进先出，消息队列是由有先级的** 

- 每个任务都有一个任务类型，**同一个类型的任务必须在同一个队列中，不同类型的任务可以分属于不同的队列**。在**一次事件循环中，浏览器可以根据实际的情况从不同的队列中取出任务执行。** 
- **浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行** 

*随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法* 

在目前的 chrome 的实现中，至少包含了下面的队列：

1. 延时队列：用于存放计时器到达后的回调任务，优先级【中】

2. 交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】

3. 微队列：用户存放需要最快执行的任务，优先级【最高】

   1. 添加任务到微任务队列的主要方式是使用 `Promise`、`MultationObserver` 

      ```js
      Promise.resolve().then(function fn() {})
      ```



## JS 计时器

JS 中的计时器不能做到精准计时：

1. 计算机硬件没有原子钟，无法做到精准计时
2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 `4 ms` 的最少事时间，这样在计算时时间少于 `4 ms` 时又带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差



**嵌套`setTimeout`的延迟问题** 

- **最小延迟限制（4ms）**：为了防止滥用定时器导致过度频繁的任务调度，浏览器对于嵌套超过一定层级（通常是 5 层）的`setTimeout`函数设置了一个最小延迟，一般是 4ms。这是一种性能优化策略，目的是避免过多的短延迟定时器任务占用过多的系统资源，从而影响浏览器的性能和用户体验。
- **具体原因分析**：当嵌套多个`setTimeout`时，可能会导致一系列非常短延迟的任务排队等待执行。如果没有这个最小延迟限制，这些任务可能会频繁地打断浏览器的其他重要任务，如页面渲染、用户输入响应等。通过添加 4ms 的最小延迟，可以让浏览器有足够的时间来处理其他任务，同时也能在一定程度上保证定时器任务的执行。例如，在一些复杂的动画效果或者频繁的异步任务场景中，如果没有这个限制，可能会导致浏览器卡顿或者资源耗尽。



## [浏览器渲染](https://web.dev/articles/howbrowserswork?hl=zh-cn) 

### 浏览器渲染页面过程

![](浏览器渲染过程.png)



1. 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列
2. 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。
3. 整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画。每个阶段都有明确的输入输出，上一个阶段的输出会成下一个阶段的输入。
   - HTML 解析过程
     - 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和外部的 JS 文件
     - 如果主线程解析到 link 标签位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作时在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。
     - 如果主线程解析到 script 标签位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML，这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停，这就是 JS 会阻塞 HTML 解析的根本原因。
   - 样式计算
     - 主线程会遍历得到的 DOM 树，依次微树中的每个节点计算出他最终的样式，称之为 Computed Style
     - 在这一过程中，很多预设值会变成绝对值，例如 `red` 会变成 `rgb(255, 0, 0);` 相对单位会变成绝对单位，例如 `em` 会变成 `px` 。这一步完成后，会得到一棵带有样式的 DOM 树。
   - 布局，布局完成后会得到布局树
     - 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含快的位置
     - 大部分时候，DOM 树和布局树并非一一对应。比如 `display: none;` 的节点没有集合信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树种不存在这些为元素节点，但他们拥有几何信息，所以会生成到布局树种。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。
   - 分层
     - 主线程会使用一套复杂的渲染对整个布局树种进行分层
     - 分层的好处在于，将来某一层改变后，仅会对该层进行后续处理，从而提升效率。
     - 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少影响分层的结果，也可以通过 `will-change` 属性更大程度的影响分层结果。
   - 分块
     - 主线程会为每个层单独生成绘制指令集，用于描述这一层的内容该如何画出来。
     - 完成绘制后，主线程将每个图层的绘制信息交给合成线程，剩余的工作将由合成线程完成。
     - 合成线程首先对每个图层进行分块，将其划分为更多的小区域，它会从线程池种拿取多个线程来完成分块工作
   - 光栅化
     - 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化
     - GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。
     - 光栅化的结果就是一块一块的位图
   - 画
     - 合成线程拿到每个层，每个块的位图后，生成一个个指引（quad）信息。
     - 指引会标识出每个位图应该画到哪个位置，以及会考虑旋转、缩放等变形
     - 变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因
     - 合成线程会把 quad 提交给 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像



### reflow

reflow 的本质就是重新计算 layout 树。

当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout

为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算，所以改动属性造成的 reflow 是异步完成的。当 JS 获取布局属性时，就可能照成无法获取到最新的布局信息。

浏览器在反复权衡下，最终决定获取属性立即 reflow

### repaint

repaint 的本质就是重新根据分层信息计算了绘制指令

当改动了可见样式后，会引发 repaint

由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint

### transform 效率

由于 transform 既不会影响布局也不会影响绘制指令，他影响的只是渲染流程的最后一个 draw 阶段

由于 draw 阶段在合成线程种，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。



 浏览器渲染过程

![WebKit 主要流程。](https://web.dev/static/articles/howbrowserswork/image/webkit-main-flow-b779d50c0cf28.png?hl=zh-cn) 



浏览器渲染DOM树

```html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```

渲染的 DOM 树如下



![](https://web.dev/static/articles/howbrowserswork/image/dom-tree-the-example-mar-70be67fe14c9a_960.png?hl=zh-cn)



### 回流、重绘

**回流 / 重排（reflow）** 

- 第一次确定节点的大小和位置，成为布局（Layout）
- 之后对节点的大小，位置修改重新计算称之为回流

引起回流：

1. DOM 结构发生改变（添加新的节点或移除节点）
2. 改变了布局（width、height、padding、font-size 等）
3. 窗口 resize （修改窗口的尺寸等）
4. 调用 getCompuedStyle 方法获取尺寸、位置信息

**重绘（repaint）** 

- 第一次渲染内容称之为绘制
- 之后重新渲染称之为重绘

引起重绘：

1. 修改背景颜色、文字颜色、边框颜色、样式等



**回流一定会引起重绘，所以回流是一种很消耗性能的事情** 

避免回流的方式：

- 修改样式时，尽量一次性修改
  - 比如：通过 cssText 修改
  - 比如：通过添加 class 修改
- 尽量避免频繁的操作 DOM
  - 可以在一个 DocumentFragment 或者父元素中将要操作的 DOM 操作完成，在一次性的操作
- 尽量避免通过 getComputedStyle 获取尺寸、位置等信息
- 对某些元素使用 position 的 absolute、fixed
  - 并不是不会回流，而是开销相对较小，不会对其他元素造成影响



### composite 合成

- 绘制的过程，可以将布局后的元素绘制到多个合成图层中，这是浏览器的一种优化手段
- 默认情况下， **标准流中的内容都是被绘制在同一个图层（Layer）中的** 
- 而一些特殊的属性，会创建一个新的合成层（Compositing Layer），并且新的图层可以利用 GPU 来加速绘制，因为 **每个合成层都是单独渲染的** 
- 常见的一些属性会导致形成新的合成层
  - 3D transforms
  - video、canvas、iframe
  - opacity 动画转换时
  - position: fixed
  - will-change：一个实验性的属性，提前告知浏览器元素可能发生哪些变化
  - animation 或 transition 设置 opacity、transform
- 分层确实可以提高新能，但是它以 **内存管理为代价** ，因此不应作为 web 性能优化策略的一部分过度使用



## 浏览器缓存

浏览器缓存是一种将资源存储在本地的技术，其目的是为了减少网络请求，提高网页的加载速度和性能。当用户访问一个网页时，浏览器会将一些静态资源（如 JavaScript 文件、CSS 文件、图片、字体等）存储在本地，下次再访问相同网页或相关资源时，可以直接从本地获取，而不是每次都从服务器请求，从而节省时间和带宽。 

### （一）强缓存

- **Expires**：
  - 这是 HTTP/1.0 中提出的缓存控制字段，它指定了资源的过期时间，是一个绝对时间，即资源在该时间之后失效。例如：`Expires: Wed, 21 Oct 2025 07:28:00 GMT`。
  - 缺点：它依赖于客户端的本地时间，如果客户端的时间不准确，可能导致缓存失效或长期不失效的问题。
- **Cache-Control**：
  - 这是 HTTP/1.1 中引入的缓存控制字段，相比`Expires`更加灵活和可靠，它可以设置多个指令，常见的指令包括：
    - `public`：表示该资源既可以被浏览器缓存，也可以被代理服务器缓存。
    - `private`：表示该资源只能被浏览器缓存，不能被代理服务器缓存。
    - `max-age`：这是一个相对时间，表示资源的有效时长，单位为秒。例如：`Cache-Control: max-age=3600`，表示资源在请求后的 3600 秒内有效。
    - `no-cache`：表示需要先与服务器确认缓存是否有效，然后决定是否使用缓存，并非不缓存。
    - `no-store`：表示不进行缓存，每次都需要从服务器请求新资源。
  - 示例：`Cache-Control: public, max-age=3600`，表示资源可被公共缓存，且在请求后的 1 小时内有效。

### （二）协商缓存

- **Last-Modified 和 If-Modified-Since**：
  - 当服务器响应资源时，会在响应头中添加`Last-Modified`字段，记录资源的最后修改时间。例如：`Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT`。
  - 当浏览器再次请求该资源时，会在请求头中带上`If-Modified-Since`字段，其值为之前服务器返回的`Last-Modified`的值。
  - 服务器收到请求后，会将`If-Modified-Since`的值与资源的实际修改时间进行比较，如果未修改，则返回`304 Not Modified`状态码，浏览器会使用本地缓存；如果修改了，则返回新资源和新的`Last-Modified`时间。
- **ETag 和 If-None-Match**：
  - `ETag`是服务器为资源生成的一个唯一标识符，通常是资源的哈希值或版本号，它比`Last-Modified`更精确，因为有些资源可能会被修改但内容不变，仅通过修改时间无法准确判断。例如：`ETag: "123456789abcdef"`。
  - 当浏览器再次请求资源时，会在请求头中带上`If-None-Match`字段，其值为之前服务器返回的`ETag`的值。
  - 服务器收到请求后，会将`If-None-Match`的值与当前资源的`ETag`进行比较，如果匹配，返回`304 Not Modified`状态码，使用本地缓存；不匹配，则返回新资源和新的`ETag`。

### 三、缓存策略的选择和使用

- **静态资源**：
  - 对于不经常更新的静态资源（如图片、CSS 文件、JavaScript 文件等），可以使用强缓存，通过设置较长的`max-age`，例如：`Cache-Control: public, max-age=31536000`（一年），减少网络请求，提高性能。
- **频繁更新的资源**：
  - 对于经常更新的资源，如 HTML 页面，可以使用协商缓存，通过`ETag`或`Last-Modified`进行验证，确保每次获取的都是最新的资源。
- **缓存失效机制**：
  - 对于可能会被更新的资源，使用`Cache-Control: no-cache`，让浏览器每次都向服务器发送请求，但服务器会根据协商缓存机制决定是否返回新资源。

### 四、浏览器缓存的流程

1. 浏览器第一次请求资源时，服务器根据资源的性质和配置，在响应头中设置相应的缓存控制信息（如`Cache-Control`、`Expires`、`ETag`、`Last-Modified`等）。
2. 浏览器根据响应头中的信息决定是否将资源存储在本地缓存中。
3. 当浏览器再次请求该资源时：

- 对于强缓存，如果未过期，直接从本地缓存中获取资源，不向服务器发送请求。
- 对于协商缓存，会带上相应的验证信息（如`If-Modified-Since`或`If-None-Match`）向服务器请求，服务器根据验证信息决定是否使用本地缓存或返回新资源。

### 五、缓存的优缺点

- **优点**：
  - 提高网页加载速度，减少网络延迟和带宽使用，提高用户体验。
  - 减轻服务器负载，减少服务器的请求处理量。
- **缺点**：
  - 可能导致用户获取到过期的资源，尤其是在使用强缓存时，更新资源可能无法及时生效，需要等待缓存过期或手动清除缓存。
  - 对于一些动态内容，如果错误地使用了强缓存，可能会影响用户看到最新信息。

### 六、缓存的清除和更新

- **手动清除**：用户可以通过浏览器的清除缓存功能，将本地缓存清除，重新从服务器获取资源。
- **自动更新：**
  - 通过合理设置缓存策略，如协商缓存，确保资源更新时能够被服务器验证，及时更新到最新资源。
  - 对于一些需要强制更新的情况，可以使用版本号或修改文件名的方式，如将`script.js`改为`script-v2.js`，使浏览器将其视为新的资源进行请求。



## script 标签阻塞页面解析

- 在浏览器解析 HTML 过程中，**遇到了 script 标签是不能继续构建 DOM 树的** 
- 他会停止继续构建，**首先下载 JavaScript 代码，并且执行 JavaScript 代码** 
- 只有 **等到 JavaScript 脚本执行结束后，才会继续解析 HTML，构建 DOM 树** 

原因：

- JavaScript 的作用之一就是操作 DOM，并且可以修改 DOM
- 如果我们 **等到 DOM 树构建完成并且渲染在执行 JavaScript，会造成严重的回流和重绘** ，影响页面的性能
- 在**遇到 script 元素时，优先下载和执行 JavaScript 代码，再继续构建 DOM 树** 

带来的问题：

- 再目前的开发模式中（Vue、React），脚本往往比 HTML 页面更 ”重“，处理时间要更长
- 所以会造成页面解析阻塞，再脚本下载，执行完成之前，用户无法在界面上看到内容
- 为了解决这个问题，**script 元素提供了两个属性（attribute）：defer 和 async** 
- *浏览器在解决这个问题时，做了一个优化操作，在解析 HTML 时，当 遇到 script 发生阻塞时，优先渲染已经生成的 DOM 树* 



## Defer 属性和 Async 属性

defer 属性 **告诉浏览器不要等待脚本下载** ，而 **继续解析 HTML ，构建 DOM 树** 

- **脚本会有浏览器来进行下载，但是不会阻塞 DOM Tree 的构建过程** 
- 如果**脚本提前下载好了，他会等待 DOM Tree 构建完成，在 `DOMContentLoaded` 事件之前先执行 defer 中的代码** 
- 在**使用 defer 属性的 script 文件中可以获取 DOM 元素** 
- defer 属性会**保证加载和执行 script 文件的顺序** 
- 从某种角度来说，defer 可以提高页面的性能，并且推荐放到 header 标签中
- defer 仅适用于外部脚本，对于 script 默认内容会被忽略
  - `<script defer> console.log('test') </script>` ，无意义，会被忽略

```js
// a.js
console.log('a script execute')
// b.js
console.log('b script execute')
```

```html
<!-- index.html -->
<div>Hello</div>
<script src="b.js" defer></script>
<script src="a.js" defer></script>
<script>
	window.addEventListenser('DOMContentLoaded', () => {
        console.log('dom content loaded')
    })
</script>
<div>Content</div>
```

如上代码执行顺序为：

1. 添加监听事件 `DOMContentLoaded` 
2. 渲染 Hello 和 Content 内容
3. 输出 `b script execute` 
4. 输出 `a script execute` 
5. 输出 `dom content loaded` 



**async 特性与 defer 有些类似，它也能够让脚本不阻塞页面**

- async 时让一个脚本完全独立
  - 浏览器 **不会因为 async 脚本而阻塞**（与 defer 类似）
  - **async 脚本不能够保证顺序，他是独立下载、独立运行、不会等待其他脚本** 
  - **async 不能保证在 `DOMContentLoaded` 之前或者之后执行** 



**defer 通常用于需要在文档解析后操作 DOM 的 JavaScript 代码，并且对于多个 script 文件有顺序的要求** 

**async 通常用于独立的脚本，对其他脚本，甚至 DOM 没有依赖** 



## JS 执行原理

浏览器内核由两部分组成，以 `webkit` 为例

- `WebCore`: 负责 HTML 解析、布局、渲染等相关的工作
- `JavaScriptCore`: 解析、执行 JavaScript 代码

**V8 引擎的执行原理：** 

- V8 是使用 C++ 编写的 Google 开源的 **高性能 JavaScript 和 `WebAssembly` 引擎**  ，它用于 Chrome 和 Node.js 等
- 它实现了 ECMAScript 和 `WebAssembly` ，并支持跨平台操作
- V8 可以独立运行，也可以嵌入到如何 C++ 应用程序中

<!-- ![](v8.png) -->
{% asset_img v8.png This is an image %}

Parse 模块会将 JavaScript 代码转化成 AST （抽象语法树），这是因为解释器并不直接认识 JavaScript 代码

- **如果函数没有被调用，那么是不会被转换成 AST 的** 

Ignition 是一个解析器，会将 AST 转化成 `ByteCode`（字节码）

- 同时**会收集 `TurboFan` 优化所需要的信息**（比如函数参数的类型信息，有了类型才能进行真实的计算）
- 如果**函数只调用一次，Ignition 会解释执行 `ByteCode`**  

`TurboFan` 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码

- 如果一个函数被多次调用那么就会被标记为 **热点函数** ，那么就会 **通过 `TurboFan` 转化成优化后的机器码**，提高代码执行的性能
- 但是，**机器码实际上也会被还原为 `ByteCode`**  这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转化为字节码

![](ast生成过程.png)

1. 词法分析（lexical analysis）
   - 将字符序列转换成 token 序列的过程
   - token 是记号化（tokenization）缩写
   - 词法分析器（lexical analyzer 简称）也叫扫描器（scanner）
2. 语法分析（syntactic analysis，也叫 parsing）
   - 语法分析器也可以称之为 parser



## JS 执行栈





## 虚拟 DOM

虚拟 DOM 可以更好的跨平台，通过生成相应的 AST（抽象语法树）进行可以在多平台复用

Vue/React 框架在数据更新时，不知道哪个组件使用了该数据，该要更新哪个组件，所以会使用 diff 算法进行对比进行渲染某个特定的组件。使用虚拟 DOM 不需要全量生成真实 DOM 渲染页面，从而能优化运行时速度

