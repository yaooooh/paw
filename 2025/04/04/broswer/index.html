<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>浏览器渲染原理 | Pulse Blog</title><meta name="author" content="DH"><meta name="copyright" content="DH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="浏览器进程模型最主要的进程包括：  浏览器进程：主要负责界面展示、用户交互、子进程管理。浏览器进程内部会启动多个线程处理不同的任务 网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务 渲染进程：渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间互不影响  渲染进程">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器渲染原理">
<meta property="og:url" content="https://yaooooh.github.io/paw/2025/04/04/broswer/index.html">
<meta property="og:site_name" content="Pulse Blog">
<meta property="og:description" content="浏览器进程模型最主要的进程包括：  浏览器进程：主要负责界面展示、用户交互、子进程管理。浏览器进程内部会启动多个线程处理不同的任务 网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务 渲染进程：渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间互不影响  渲染进程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yaooooh.github.io/paw/images/favicon.ico">
<meta property="article:published_time" content="2025-04-04T08:31:42.000Z">
<meta property="article:modified_time" content="2025-09-03T16:29:24.956Z">
<meta property="article:author" content="DH">
<meta property="article:tag" content="浏览器">
<meta property="article:tag" content="渲染原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yaooooh.github.io/paw/images/favicon.ico"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浏览器渲染原理",
  "url": "https://yaooooh.github.io/paw/2025/04/04/broswer/",
  "image": "https://yaooooh.github.io/paw/images/favicon.ico",
  "datePublished": "2025-04-04T08:31:42.000Z",
  "dateModified": "2025-09-03T16:29:24.956Z",
  "author": [
    {
      "@type": "Person",
      "name": "DH",
      "url": "https://yaooooh.github.io/paw"
    }
  ]
}</script><link rel="shortcut icon" href="/paw/images/favicon.ico"><link rel="canonical" href="https://yaooooh.github.io/paw/2025/04/04/broswer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/paw/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/paw/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浏览器渲染原理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/paw/images/favicon.ico" onerror="this.onerror=null;this.src='/paw/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/paw/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/paw/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/paw/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/paw/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/paw/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/paw/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/paw/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/paw/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/paw/"><img class="site-icon" src="/paw/images/favicon.ico" alt="Logo"><span class="site-name">Pulse Blog</span></a><a class="nav-page-title" href="/paw/"><span class="site-name">浏览器渲染原理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/paw/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/paw/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/paw/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/paw/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/paw/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">浏览器渲染原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-04T08:31:42.000Z" title="Created 2025-04-04 16:31:42">2025-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-03T16:29:24.956Z" title="Updated 2025-09-04 00:29:24">2025-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/paw/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="浏览器进程模型"><a href="#浏览器进程模型" class="headerlink" title="浏览器进程模型"></a>浏览器进程模型</h2><p>最主要的进程包括：</p>
<ol>
<li>浏览器进程：主要负责界面展示、用户交互、子进程管理。浏览器进程内部会启动多个线程处理不同的任务</li>
<li>网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</li>
<li>渲染进程：渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间互不影响</li>
</ol>
<h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><ol>
<li>在最开始的时候，渲染主线程会进入一个无限循环</li>
<li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完之后进入下一个循环，如果没有，则进入休眠状态</li>
<li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加入到消息队列的末尾，在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li>
</ol>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul>
<li>单线程是异步产生的原因</li>
<li>事件循环是异步实现的方式</li>
</ul>
<p>JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>
<p>而渲染主线程承担着诸多的工作，渲染页面，执行 JS 都在其中运行。</p>
<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程拜拜的消耗事件，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>
<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听、主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他任务完成时，将实现传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>
<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p><strong>任务没有优先级，在消息队列中先进先出，消息队列是由有先级的</strong> </p>
<ul>
<li>每个任务都有一个任务类型，<strong>同一个类型的任务必须在同一个队列中，不同类型的任务可以分属于不同的队列</strong>。在<strong>一次事件循环中，浏览器可以根据实际的情况从不同的队列中取出任务执行。</strong> </li>
<li><strong>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行</strong></li>
</ul>
<p><em>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</em> </p>
<p>在目前的 chrome 的实现中，至少包含了下面的队列：</p>
<ol>
<li><p>延时队列：用于存放计时器到达后的回调任务，优先级【中】</p>
</li>
<li><p>交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】</p>
</li>
<li><p>微队列：用户存放需要最快执行的任务，优先级【最高】</p>
<ol>
<li><p>添加任务到微任务队列的主要方式是使用 <code>Promise</code>、<code>MultationObserver</code> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="JS-计时器"><a href="#JS-计时器" class="headerlink" title="JS 计时器"></a>JS 计时器</h2><p>JS 中的计时器不能做到精准计时：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精准计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 <code>4 ms</code> 的最少事时间，这样在计算时时间少于 <code>4 ms</code> 时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
<p><strong>嵌套<code>setTimeout</code>的延迟问题</strong> </p>
<ul>
<li><strong>最小延迟限制（4ms）</strong>：为了防止滥用定时器导致过度频繁的任务调度，浏览器对于嵌套超过一定层级（通常是 5 层）的<code>setTimeout</code>函数设置了一个最小延迟，一般是 4ms。这是一种性能优化策略，目的是避免过多的短延迟定时器任务占用过多的系统资源，从而影响浏览器的性能和用户体验。</li>
<li><strong>具体原因分析</strong>：当嵌套多个<code>setTimeout</code>时，可能会导致一系列非常短延迟的任务排队等待执行。如果没有这个最小延迟限制，这些任务可能会频繁地打断浏览器的其他重要任务，如页面渲染、用户输入响应等。通过添加 4ms 的最小延迟，可以让浏览器有足够的时间来处理其他任务，同时也能在一定程度上保证定时器任务的执行。例如，在一些复杂的动画效果或者频繁的异步任务场景中，如果没有这个限制，可能会导致浏览器卡顿或者资源耗尽。</li>
</ul>
<h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a><a target="_blank" rel="noopener" href="https://web.dev/articles/howbrowserswork?hl=zh-cn">浏览器渲染</a></h2><h3 id="浏览器渲染页面过程"><a href="#浏览器渲染页面过程" class="headerlink" title="浏览器渲染页面过程"></a>浏览器渲染页面过程</h3><p><img src="/paw/2025/04/04/broswer/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png"></p>
<ol>
<li>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列</li>
<li>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</li>
<li>整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画。每个阶段都有明确的输入输出，上一个阶段的输出会成下一个阶段的输入。<ul>
<li>HTML 解析过程<ul>
<li>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和外部的 JS 文件</li>
<li>如果主线程解析到 link 标签位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作时在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</li>
<li>如果主线程解析到 script 标签位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML，这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停，这就是 JS 会阻塞 HTML 解析的根本原因。</li>
</ul>
</li>
<li>样式计算<ul>
<li>主线程会遍历得到的 DOM 树，依次微树中的每个节点计算出他最终的样式，称之为 Computed Style</li>
<li>在这一过程中，很多预设值会变成绝对值，例如 <code>red</code> 会变成 <code>rgb(255, 0, 0);</code> 相对单位会变成绝对单位，例如 <code>em</code> 会变成 <code>px</code> 。这一步完成后，会得到一棵带有样式的 DOM 树。</li>
</ul>
</li>
<li>布局，布局完成后会得到布局树<ul>
<li>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含快的位置</li>
<li>大部分时候，DOM 树和布局树并非一一对应。比如 <code>display: none;</code> 的节点没有集合信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树种不存在这些为元素节点，但他们拥有几何信息，所以会生成到布局树种。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</li>
</ul>
</li>
<li>分层<ul>
<li>主线程会使用一套复杂的渲染对整个布局树种进行分层</li>
<li>分层的好处在于，将来某一层改变后，仅会对该层进行后续处理，从而提升效率。</li>
<li>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少影响分层的结果，也可以通过 <code>will-change</code> 属性更大程度的影响分层结果。</li>
</ul>
</li>
<li>分块<ul>
<li>主线程会为每个层单独生成绘制指令集，用于描述这一层的内容该如何画出来。</li>
<li>完成绘制后，主线程将每个图层的绘制信息交给合成线程，剩余的工作将由合成线程完成。</li>
<li>合成线程首先对每个图层进行分块，将其划分为更多的小区域，它会从线程池种拿取多个线程来完成分块工作</li>
</ul>
</li>
<li>光栅化<ul>
<li>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化</li>
<li>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</li>
<li>光栅化的结果就是一块一块的位图</li>
</ul>
</li>
<li>画<ul>
<li>合成线程拿到每个层，每个块的位图后，生成一个个指引（quad）信息。</li>
<li>指引会标识出每个位图应该画到哪个位置，以及会考虑旋转、缩放等变形</li>
<li>变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因</li>
<li>合成线程会把 quad 提交给 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="reflow"><a href="#reflow" class="headerlink" title="reflow"></a>reflow</h3><p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算，所以改动属性造成的 reflow 是异步完成的。当 JS 获取布局属性时，就可能照成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 reflow</p>
<h3 id="repaint"><a href="#repaint" class="headerlink" title="repaint"></a>repaint</h3><p>repaint 的本质就是重新根据分层信息计算了绘制指令</p>
<p>当改动了可见样式后，会引发 repaint</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint</p>
<h3 id="transform-效率"><a href="#transform-效率" class="headerlink" title="transform 效率"></a>transform 效率</h3><p>由于 transform 既不会影响布局也不会影响绘制指令，他影响的只是渲染流程的最后一个 draw 阶段</p>
<p>由于 draw 阶段在合成线程种，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<p> 浏览器渲染过程</p>
<p><img src="https://web.dev/static/articles/howbrowserswork/image/webkit-main-flow-b779d50c0cf28.png?hl=zh-cn" alt="WebKit 主要流程。"> </p>
<p>浏览器渲染DOM树</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;example.png&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染的 DOM 树如下</p>
<p><img src="https://web.dev/static/articles/howbrowserswork/image/dom-tree-the-example-mar-70be67fe14c9a_960.png?hl=zh-cn"></p>
<h3 id="回流、重绘"><a href="#回流、重绘" class="headerlink" title="回流、重绘"></a>回流、重绘</h3><p><strong>回流 &#x2F; 重排（reflow）</strong> </p>
<ul>
<li>第一次确定节点的大小和位置，成为布局（Layout）</li>
<li>之后对节点的大小，位置修改重新计算称之为回流</li>
</ul>
<p>引起回流：</p>
<ol>
<li>DOM 结构发生改变（添加新的节点或移除节点）</li>
<li>改变了布局（width、height、padding、font-size 等）</li>
<li>窗口 resize （修改窗口的尺寸等）</li>
<li>调用 getCompuedStyle 方法获取尺寸、位置信息</li>
</ol>
<p><strong>重绘（repaint）</strong> </p>
<ul>
<li>第一次渲染内容称之为绘制</li>
<li>之后重新渲染称之为重绘</li>
</ul>
<p>引起重绘：</p>
<ol>
<li>修改背景颜色、文字颜色、边框颜色、样式等</li>
</ol>
<p><strong>回流一定会引起重绘，所以回流是一种很消耗性能的事情</strong> </p>
<p>避免回流的方式：</p>
<ul>
<li>修改样式时，尽量一次性修改<ul>
<li>比如：通过 cssText 修改</li>
<li>比如：通过添加 class 修改</li>
</ul>
</li>
<li>尽量避免频繁的操作 DOM<ul>
<li>可以在一个 DocumentFragment 或者父元素中将要操作的 DOM 操作完成，在一次性的操作</li>
</ul>
</li>
<li>尽量避免通过 getComputedStyle 获取尺寸、位置等信息</li>
<li>对某些元素使用 position 的 absolute、fixed<ul>
<li>并不是不会回流，而是开销相对较小，不会对其他元素造成影响</li>
</ul>
</li>
</ul>
<h3 id="composite-合成"><a href="#composite-合成" class="headerlink" title="composite 合成"></a>composite 合成</h3><ul>
<li>绘制的过程，可以将布局后的元素绘制到多个合成图层中，这是浏览器的一种优化手段</li>
<li>默认情况下， <strong>标准流中的内容都是被绘制在同一个图层（Layer）中的</strong> </li>
<li>而一些特殊的属性，会创建一个新的合成层（Compositing Layer），并且新的图层可以利用 GPU 来加速绘制，因为 <strong>每个合成层都是单独渲染的</strong> </li>
<li>常见的一些属性会导致形成新的合成层<ul>
<li>3D transforms</li>
<li>video、canvas、iframe</li>
<li>opacity 动画转换时</li>
<li>position: fixed</li>
<li>will-change：一个实验性的属性，提前告知浏览器元素可能发生哪些变化</li>
<li>animation 或 transition 设置 opacity、transform</li>
</ul>
</li>
<li>分层确实可以提高新能，但是它以 <strong>内存管理为代价</strong> ，因此不应作为 web 性能优化策略的一部分过度使用</li>
</ul>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>浏览器缓存是一种将资源存储在本地的技术，其目的是为了减少网络请求，提高网页的加载速度和性能。当用户访问一个网页时，浏览器会将一些静态资源（如 JavaScript 文件、CSS 文件、图片、字体等）存储在本地，下次再访问相同网页或相关资源时，可以直接从本地获取，而不是每次都从服务器请求，从而节省时间和带宽。 </p>
<h3 id="（一）强缓存"><a href="#（一）强缓存" class="headerlink" title="（一）强缓存"></a>（一）强缓存</h3><ul>
<li><strong>Expires</strong>：<ul>
<li>这是 HTTP&#x2F;1.0 中提出的缓存控制字段，它指定了资源的过期时间，是一个绝对时间，即资源在该时间之后失效。例如：<code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code>。</li>
<li>缺点：它依赖于客户端的本地时间，如果客户端的时间不准确，可能导致缓存失效或长期不失效的问题。</li>
</ul>
</li>
<li><strong>Cache-Control</strong>：<ul>
<li>这是 HTTP&#x2F;1.1 中引入的缓存控制字段，相比<code>Expires</code>更加灵活和可靠，它可以设置多个指令，常见的指令包括：<ul>
<li><code>public</code>：表示该资源既可以被浏览器缓存，也可以被代理服务器缓存。</li>
<li><code>private</code>：表示该资源只能被浏览器缓存，不能被代理服务器缓存。</li>
<li><code>max-age</code>：这是一个相对时间，表示资源的有效时长，单位为秒。例如：<code>Cache-Control: max-age=3600</code>，表示资源在请求后的 3600 秒内有效。</li>
<li><code>no-cache</code>：表示需要先与服务器确认缓存是否有效，然后决定是否使用缓存，并非不缓存。</li>
<li><code>no-store</code>：表示不进行缓存，每次都需要从服务器请求新资源。</li>
</ul>
</li>
<li>示例：<code>Cache-Control: public, max-age=3600</code>，表示资源可被公共缓存，且在请求后的 1 小时内有效。</li>
</ul>
</li>
</ul>
<h3 id="（二）协商缓存"><a href="#（二）协商缓存" class="headerlink" title="（二）协商缓存"></a>（二）协商缓存</h3><ul>
<li><strong>Last-Modified 和 If-Modified-Since</strong>：<ul>
<li>当服务器响应资源时，会在响应头中添加<code>Last-Modified</code>字段，记录资源的最后修改时间。例如：<code>Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT</code>。</li>
<li>当浏览器再次请求该资源时，会在请求头中带上<code>If-Modified-Since</code>字段，其值为之前服务器返回的<code>Last-Modified</code>的值。</li>
<li>服务器收到请求后，会将<code>If-Modified-Since</code>的值与资源的实际修改时间进行比较，如果未修改，则返回<code>304 Not Modified</code>状态码，浏览器会使用本地缓存；如果修改了，则返回新资源和新的<code>Last-Modified</code>时间。</li>
</ul>
</li>
<li><strong>ETag 和 If-None-Match</strong>：<ul>
<li><code>ETag</code>是服务器为资源生成的一个唯一标识符，通常是资源的哈希值或版本号，它比<code>Last-Modified</code>更精确，因为有些资源可能会被修改但内容不变，仅通过修改时间无法准确判断。例如：<code>ETag: &quot;123456789abcdef&quot;</code>。</li>
<li>当浏览器再次请求资源时，会在请求头中带上<code>If-None-Match</code>字段，其值为之前服务器返回的<code>ETag</code>的值。</li>
<li>服务器收到请求后，会将<code>If-None-Match</code>的值与当前资源的<code>ETag</code>进行比较，如果匹配，返回<code>304 Not Modified</code>状态码，使用本地缓存；不匹配，则返回新资源和新的<code>ETag</code>。</li>
</ul>
</li>
</ul>
<h3 id="三、缓存策略的选择和使用"><a href="#三、缓存策略的选择和使用" class="headerlink" title="三、缓存策略的选择和使用"></a>三、缓存策略的选择和使用</h3><ul>
<li><strong>静态资源</strong>：<ul>
<li>对于不经常更新的静态资源（如图片、CSS 文件、JavaScript 文件等），可以使用强缓存，通过设置较长的<code>max-age</code>，例如：<code>Cache-Control: public, max-age=31536000</code>（一年），减少网络请求，提高性能。</li>
</ul>
</li>
<li><strong>频繁更新的资源</strong>：<ul>
<li>对于经常更新的资源，如 HTML 页面，可以使用协商缓存，通过<code>ETag</code>或<code>Last-Modified</code>进行验证，确保每次获取的都是最新的资源。</li>
</ul>
</li>
<li><strong>缓存失效机制</strong>：<ul>
<li>对于可能会被更新的资源，使用<code>Cache-Control: no-cache</code>，让浏览器每次都向服务器发送请求，但服务器会根据协商缓存机制决定是否返回新资源。</li>
</ul>
</li>
</ul>
<h3 id="四、浏览器缓存的流程"><a href="#四、浏览器缓存的流程" class="headerlink" title="四、浏览器缓存的流程"></a>四、浏览器缓存的流程</h3><ol>
<li>浏览器第一次请求资源时，服务器根据资源的性质和配置，在响应头中设置相应的缓存控制信息（如<code>Cache-Control</code>、<code>Expires</code>、<code>ETag</code>、<code>Last-Modified</code>等）。</li>
<li>浏览器根据响应头中的信息决定是否将资源存储在本地缓存中。</li>
<li>当浏览器再次请求该资源时：</li>
</ol>
<ul>
<li>对于强缓存，如果未过期，直接从本地缓存中获取资源，不向服务器发送请求。</li>
<li>对于协商缓存，会带上相应的验证信息（如<code>If-Modified-Since</code>或<code>If-None-Match</code>）向服务器请求，服务器根据验证信息决定是否使用本地缓存或返回新资源。</li>
</ul>
<h3 id="五、缓存的优缺点"><a href="#五、缓存的优缺点" class="headerlink" title="五、缓存的优缺点"></a>五、缓存的优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li>提高网页加载速度，减少网络延迟和带宽使用，提高用户体验。</li>
<li>减轻服务器负载，减少服务器的请求处理量。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>可能导致用户获取到过期的资源，尤其是在使用强缓存时，更新资源可能无法及时生效，需要等待缓存过期或手动清除缓存。</li>
<li>对于一些动态内容，如果错误地使用了强缓存，可能会影响用户看到最新信息。</li>
</ul>
</li>
</ul>
<h3 id="六、缓存的清除和更新"><a href="#六、缓存的清除和更新" class="headerlink" title="六、缓存的清除和更新"></a>六、缓存的清除和更新</h3><ul>
<li><strong>手动清除</strong>：用户可以通过浏览器的清除缓存功能，将本地缓存清除，重新从服务器获取资源。</li>
<li><strong>自动更新：</strong><ul>
<li>通过合理设置缓存策略，如协商缓存，确保资源更新时能够被服务器验证，及时更新到最新资源。</li>
<li>对于一些需要强制更新的情况，可以使用版本号或修改文件名的方式，如将<code>script.js</code>改为<code>script-v2.js</code>，使浏览器将其视为新的资源进行请求。</li>
</ul>
</li>
</ul>
<h2 id="script-标签阻塞页面解析"><a href="#script-标签阻塞页面解析" class="headerlink" title="script 标签阻塞页面解析"></a>script 标签阻塞页面解析</h2><ul>
<li>在浏览器解析 HTML 过程中，<strong>遇到了 script 标签是不能继续构建 DOM 树的</strong> </li>
<li>他会停止继续构建，<strong>首先下载 JavaScript 代码，并且执行 JavaScript 代码</strong> </li>
<li>只有 <strong>等到 JavaScript 脚本执行结束后，才会继续解析 HTML，构建 DOM 树</strong></li>
</ul>
<p>原因：</p>
<ul>
<li>JavaScript 的作用之一就是操作 DOM，并且可以修改 DOM</li>
<li>如果我们 <strong>等到 DOM 树构建完成并且渲染在执行 JavaScript，会造成严重的回流和重绘</strong> ，影响页面的性能</li>
<li>在<strong>遇到 script 元素时，优先下载和执行 JavaScript 代码，再继续构建 DOM 树</strong></li>
</ul>
<p>带来的问题：</p>
<ul>
<li>再目前的开发模式中（Vue、React），脚本往往比 HTML 页面更 ”重“，处理时间要更长</li>
<li>所以会造成页面解析阻塞，再脚本下载，执行完成之前，用户无法在界面上看到内容</li>
<li>为了解决这个问题，<strong>script 元素提供了两个属性（attribute）：defer 和 async</strong> </li>
<li><em>浏览器在解决这个问题时，做了一个优化操作，在解析 HTML 时，当 遇到 script 发生阻塞时，优先渲染已经生成的 DOM 树</em></li>
</ul>
<h2 id="Defer-属性和-Async-属性"><a href="#Defer-属性和-Async-属性" class="headerlink" title="Defer 属性和 Async 属性"></a>Defer 属性和 Async 属性</h2><p>defer 属性 <strong>告诉浏览器不要等待脚本下载</strong> ，而 <strong>继续解析 HTML ，构建 DOM 树</strong> </p>
<ul>
<li><strong>脚本会有浏览器来进行下载，但是不会阻塞 DOM Tree 的构建过程</strong> </li>
<li>如果<strong>脚本提前下载好了，他会等待 DOM Tree 构建完成，在 <code>DOMContentLoaded</code> 事件之前先执行 defer 中的代码</strong> </li>
<li>在<strong>使用 defer 属性的 script 文件中可以获取 DOM 元素</strong> </li>
<li>defer 属性会<strong>保证加载和执行 script 文件的顺序</strong> </li>
<li>从某种角度来说，defer 可以提高页面的性能，并且推荐放到 header 标签中</li>
<li>defer 仅适用于外部脚本，对于 script 默认内容会被忽略<ul>
<li><code>&lt;script defer&gt; console.log(&#39;test&#39;) &lt;/script&gt;</code> ，无意义，会被忽略</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a script execute&#x27;</span>)</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b script execute&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">window</span>.<span class="title function_">addEventListenser</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dom content loaded&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上代码执行顺序为：</p>
<ol>
<li>添加监听事件 <code>DOMContentLoaded</code> </li>
<li>渲染 Hello 和 Content 内容</li>
<li>输出 <code>b script execute</code> </li>
<li>输出 <code>a script execute</code> </li>
<li>输出 <code>dom content loaded</code></li>
</ol>
<p><strong>async 特性与 defer 有些类似，它也能够让脚本不阻塞页面</strong></p>
<ul>
<li>async 时让一个脚本完全独立<ul>
<li>浏览器 <strong>不会因为 async 脚本而阻塞</strong>（与 defer 类似）</li>
<li><strong>async 脚本不能够保证顺序，他是独立下载、独立运行、不会等待其他脚本</strong> </li>
<li><strong>async 不能保证在 <code>DOMContentLoaded</code> 之前或者之后执行</strong></li>
</ul>
</li>
</ul>
<p><strong>defer 通常用于需要在文档解析后操作 DOM 的 JavaScript 代码，并且对于多个 script 文件有顺序的要求</strong> </p>
<p><strong>async 通常用于独立的脚本，对其他脚本，甚至 DOM 没有依赖</strong> </p>
<h2 id="JS-执行原理"><a href="#JS-执行原理" class="headerlink" title="JS 执行原理"></a>JS 执行原理</h2><p>浏览器内核由两部分组成，以 <code>webkit</code> 为例</p>
<ul>
<li><code>WebCore</code>: 负责 HTML 解析、布局、渲染等相关的工作</li>
<li><code>JavaScriptCore</code>: 解析、执行 JavaScript 代码</li>
</ul>
<p><strong>V8 引擎的执行原理：</strong> </p>
<ul>
<li>V8 是使用 C++ 编写的 Google 开源的 <strong>高性能 JavaScript 和 <code>WebAssembly</code> 引擎</strong>  ，它用于 Chrome 和 Node.js 等</li>
<li>它实现了 ECMAScript 和 <code>WebAssembly</code> ，并支持跨平台操作</li>
<li>V8 可以独立运行，也可以嵌入到如何 C++ 应用程序中</li>
</ul>
<!-- ![](v8.png) -->
<img src="/paw/2025/04/04/broswer/v8.png" class="" title="This is an image">

<p>Parse 模块会将 JavaScript 代码转化成 AST （抽象语法树），这是因为解释器并不直接认识 JavaScript 代码</p>
<ul>
<li><strong>如果函数没有被调用，那么是不会被转换成 AST 的</strong></li>
</ul>
<p>Ignition 是一个解析器，会将 AST 转化成 <code>ByteCode</code>（字节码）</p>
<ul>
<li>同时<strong>会收集 <code>TurboFan</code> 优化所需要的信息</strong>（比如函数参数的类型信息，有了类型才能进行真实的计算）</li>
<li>如果<strong>函数只调用一次，Ignition 会解释执行 <code>ByteCode</code></strong></li>
</ul>
<p><code>TurboFan</code> 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码</p>
<ul>
<li>如果一个函数被多次调用那么就会被标记为 <strong>热点函数</strong> ，那么就会 <strong>通过 <code>TurboFan</code> 转化成优化后的机器码</strong>，提高代码执行的性能</li>
<li>但是，<strong>机器码实际上也会被还原为 <code>ByteCode</code></strong>  这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转化为字节码</li>
</ul>
<p><img src="/paw/2025/04/04/broswer/ast%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png"></p>
<ol>
<li>词法分析（lexical analysis）<ul>
<li>将字符序列转换成 token 序列的过程</li>
<li>token 是记号化（tokenization）缩写</li>
<li>词法分析器（lexical analyzer 简称）也叫扫描器（scanner）</li>
</ul>
</li>
<li>语法分析（syntactic analysis，也叫 parsing）<ul>
<li>语法分析器也可以称之为 parser</li>
</ul>
</li>
</ol>
<h2 id="JS-执行栈"><a href="#JS-执行栈" class="headerlink" title="JS 执行栈"></a>JS 执行栈</h2><h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p>虚拟 DOM 可以更好的跨平台，通过生成相应的 AST（抽象语法树）进行可以在多平台复用</p>
<p>Vue&#x2F;React 框架在数据更新时，不知道哪个组件使用了该数据，该要更新哪个组件，所以会使用 diff 算法进行对比进行渲染某个特定的组件。使用虚拟 DOM 不需要全量生成真实 DOM 渲染页面，从而能优化运行时速度</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://yaooooh.github.io/paw">DH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://yaooooh.github.io/paw/2025/04/04/broswer/">https://yaooooh.github.io/paw/2025/04/04/broswer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/paw/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><a class="post-meta__tags" href="/paw/tags/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">渲染原理</a></div><div class="post-share"><div class="social-share" data-image="/paw/images/favicon.ico" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/paw/2025/04/04/js%E9%AB%98%E7%BA%A7/" title="JS 高级内容"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">JS 高级内容</div></div><div class="info-2"><div class="info-item-1">基础基本数据类型：number、string、undefined、null、boolean、symbol 引用数据类型：Array、Object、Function、Date、Regex 块级作用域let 和 const  全局定义的变量不再作为属性添加到全局对象中 在变量定义之前使用它会报错 不可重复定义同名变量 使用 const 定义变量时，必须初始化 变量具有会计作用域，在代码块之外不可以使用 在 for 循环中使用 let 定义变量，变量所在的作用域是循环体，也因此在循环外不能使用。 另外 for 循环会对该变量做特殊处理，让每次循环使用的都是一个独立的循环变量，这可以解决 JS 由来已久的问题    class 和 function ：相同点：  class 和 function 都可以作为构造函数，通过 new 操作符来实例化。  类可以包含构造函数方法、实例方法、setter 函数、getter 函数和静态类方法，但这些 都不是 必须的。  不同点：  class 构造函数必须使用 new 操作符  class 声明不可以提升 12345678910111213141...</div></div></div></a><a class="pagination-related" href="/paw/2025/04/01/408/" title="HTTP 发展史"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">HTTP 发展史</div></div><div class="info-2"><div class="info-item-1">Http1.0 &#x2F; Http1.1 &#x2F; Https HTTP0.9  发布于 1991 年 只支持 GET 请求方法获取文本数据，当时主要是为了获取 HTML 页面内容   HTTP1.0  发布于 1996 年  支持 POST、HEAD 等请求方法，支持请求头，响应头等，支持更多种数据类型，不再局限于文本数据  但是浏览器的每次请求都需要与服务器建立一个 TCP 链接，请求处理完成之后立即断开连接，每次建立连接增加了性能损耗  基本特性  简单的请求 - 响应模式：HTTP1.0 采用了基本的请求 - 响应通信模式。客户端发送一个请求到服务器，服务器处理请求后返回一个响应。例如，当浏览器请求一个网页时，会发送一个包含请求方法（如 GET）、请求的资源路径（如 &#x2F;index.html）等信息的请求报文，服务器根据请求内容查找资源并返回包含 HTML 文档的响应报文。 有限的连接复用能力：在 HTTP1.0 中，每个请求 - 响应过程通常需要建立一个新的 TCP 连接。这意味着如果一个网页包含多个资源（如多个图片、CSS 文件、JavaScript ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/paw/images/favicon.ico" onerror="this.onerror=null;this.src='/paw/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DH</div><div class="author-info-description"></div><div class="site-data"><a href="/paw/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/paw/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/paw/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">浏览器进程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">渲染进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">任务队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">JS 计时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">3.</span> <span class="toc-text">浏览器渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">浏览器渲染页面过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflow"><span class="toc-number">3.2.</span> <span class="toc-text">reflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#repaint"><span class="toc-number">3.3.</span> <span class="toc-text">repaint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform-%E6%95%88%E7%8E%87"><span class="toc-number">3.4.</span> <span class="toc-text">transform 效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E3%80%81%E9%87%8D%E7%BB%98"><span class="toc-number">3.5.</span> <span class="toc-text">回流、重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#composite-%E5%90%88%E6%88%90"><span class="toc-number">3.6.</span> <span class="toc-text">composite 合成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">（一）强缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.</span> <span class="toc-text">（二）协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">三、缓存策略的选择和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">四、浏览器缓存的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">五、缓存的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BC%93%E5%AD%98%E7%9A%84%E6%B8%85%E9%99%A4%E5%92%8C%E6%9B%B4%E6%96%B0"><span class="toc-number">4.6.</span> <span class="toc-text">六、缓存的清除和更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#script-%E6%A0%87%E7%AD%BE%E9%98%BB%E5%A1%9E%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">script 标签阻塞页面解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Defer-%E5%B1%9E%E6%80%A7%E5%92%8C-Async-%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">Defer 属性和 Async 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">JS 执行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-number">8.</span> <span class="toc-text">JS 执行栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">9.</span> <span class="toc-text">虚拟 DOM</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/paw/2025/04/25/seo/" title="搜索引擎优化">搜索引擎优化</a><time datetime="2025-04-25T15:31:42.000Z" title="Created 2025-04-25 23:31:42">2025-04-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/paw/2025/04/19/react/" title="React 学习笔记">React 学习笔记</a><time datetime="2025-04-19T12:31:42.000Z" title="Created 2025-04-19 20:31:42">2025-04-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/paw/2025/04/08/learn/" title="Node 学习笔记">Node 学习笔记</a><time datetime="2025-04-08T15:31:42.000Z" title="Created 2025-04-08 23:31:42">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/paw/2025/04/08/css/" title="CSS 高级">CSS 高级</a><time datetime="2025-04-08T05:31:42.000Z" title="Created 2025-04-08 13:31:42">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/paw/2025/04/04/js%E9%AB%98%E7%BA%A7/" title="JS 高级内容">JS 高级内容</a><time datetime="2025-04-04T11:31:42.000Z" title="Created 2025-04-04 19:31:42">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By DH</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/paw/js/utils.js"></script><script src="/paw/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>